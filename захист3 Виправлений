from PIL import Image
import numpy as np
import os
import math
import matplotlib.pyplot as plt

START_MARK = b"<start>"
END_MARK = b"<end>"

def bytes_to_bits(data: bytes) -> str:
    return ''.join(f'{byte:08b}' for byte in data)

def bits_to_bytes(bits: str) -> bytes:
    
    extra = len(bits) % 8
    if extra != 0:
        bits = bits + ('0' * (8 - extra))
    return bytes(int(bits[i:i+8], 2) for i in range(0, len(bits), 8))

def hide_message(input_image_path: str, output_image_path: str, message: str):
    """
    Ховає message (str, UTF-8) в зображенні input_image_path і зберігає в output_image_path (PNG).
    Підтримує тільки RGB-зображення (конвертує при потребі).
    """
    img = Image.open(input_image_path)
    if img.mode != 'RGB':
        img = img.convert('RGB')
    width, height = img.size
    max_bits = width * height * 3

   
    payload_bytes = START_MARK + message.encode('utf-8') + END_MARK
    payload_bits = bytes_to_bits(payload_bytes)

    if len(payload_bits) > max_bits:
        raise ValueError(f"Повідомлення занадто велике для цього зображення.\n"
                         f"Максимально доступні біти: {max_bits}, потрібно: {len(payload_bits)}")

    pixels = np.array(img)  
    flat = pixels.reshape(-1, 3)  

    bit_idx = 0
    total_bits = len(payload_bits)

    for i in range(flat.shape[0]):
        for ch in range(3):  
            if bit_idx < total_bits:
                bit = int(payload_bits[bit_idx])
                flat[i, ch] = (flat[i, ch] & ~1) | bit
                bit_idx += 1
            else:
                break
        if bit_idx >= total_bits:
            break

   
    new_pixels = flat.reshape(pixels.shape).astype(np.uint8)
    encoded_img = Image.fromarray(new_pixels, mode='RGB')
    encoded_img.save(output_image_path, format='PNG')
    print(f"[+] Повідомлення заховано у {output_image_path} (використано {bit_idx}/{max_bits} бітів).")

def extract_message(input_image_path: str, max_bytes: int = None) -> str:
    """
    Витягує приховане повідомлення з зображення.
    Повертає рядок (декодований UTF-8) або порожній рядок, якщо маркери не знайдені.
    max_bytes - необов'язково: обмежує кількість байтів для витягування (безпечніше при дуже великих зображеннях).
    """
    img = Image.open(input_image_path)
    if img.mode != 'RGB':
        img = img.convert('RGB')
    pixels = np.array(img)
    flat = pixels.reshape(-1, 3)

    bits = []
    for i in range(flat.shape[0]):
        for ch in range(3):
            bits.append(str(int(flat[i, ch] & 1)))
    bits_str = ''.join(bits)

    data_bytes = []
    for i in range(0, len(bits_str), 8):
        byte_bits = bits_str[i:i+8]
        if len(byte_bits) < 8:
            break
        data_bytes.append(int(byte_bits, 2))
      
        if max_bytes is not None and len(data_bytes) >= max_bytes:
            break

    data = bytes(data_bytes)
    start = data.find(START_MARK)
    end = data.find(END_MARK)

    if start != -1 and end != -1 and end > start:
        message_bytes = data[start+len(START_MARK):end]
        try:
            message = message_bytes.decode('utf-8')
        except UnicodeDecodeError:
            
            message = message_bytes.decode('utf-8', errors='replace')
        print("[+] Повідомлення успішно витягнуто.")
        return message
    else:
        print("[-] Маркери не знайдені — повідомлення відсутнє або пошкоджене.")
        return ""

def file_size_bytes(path):
    return os.path.getsize(path)

def mse(img1: Image.Image, img2: Image.Image) -> float:
    a = np.array(img1).astype(np.float64)
    b = np.array(img2).astype(np.float64)
    if a.shape != b.shape:
        raise ValueError("Розміри зображень не співпадають для обчислення MSE")
    err = np.mean((a - b) ** 2)
    return float(err)

def psnr(img1: Image.Image, img2: Image.Image) -> float:
    m = mse(img1, img2)
    if m == 0:
        return float('inf')
    PIXEL_MAX = 255.0
    return 20 * math.log10(PIXEL_MAX / math.sqrt(m))

def visualize_comparison(orig_path: str, encoded_path: str):
    orig = Image.open(orig_path).convert('RGB')
    enc = Image.open(encoded_path).convert('RGB')

    print("Розмір файлів (байт):")
    print(" - Оригінал:", file_size_bytes(orig_path))
    print(" - З модифікацією:", file_size_bytes(encoded_path))

    print("MSE:", mse(orig, enc))
    print("PSNR:", psnr(orig, enc))

    fig, axs = plt.subplots(1, 2, figsize=(12, 6))
    axs[0].imshow(orig)
    axs[0].set_title("Оригінал")
    axs[0].axis('off')

    axs[1].imshow(enc)
    axs[1].set_title("Заховане повідомлення")
    axs[1].axis('off')

    plt.show()

if __name__ == "__main__":
 
    original_image = "D:/загруженолрзахист2.png"   
    output_image = "encoded.png"
    secret_text = "Прив Це тестове повідомлення з UTF-8: Україна, 12345."

    if not os.path.exists(original_image):
        print(f"Файл '{original_image}' не знайдено. Помістіть PNG-файл з таким ім'ям у ту саму папку або змініть шлях у скрипті.")
    else:
      
        hide_message(original_image, output_image, secret_text)

       
        extracted = extract_message(output_image)
        print("Витягнуте повідомлення:")
        print(extracted)

   
        visualize_comparison(original_image, output_image)



